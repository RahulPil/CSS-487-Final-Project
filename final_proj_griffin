#define BIT_ISSET(var, pos) (!!((var) & (1ULL<<(pos))))
#define BORDER_PERCENT_ERROR_THRESHHOLD 40
#define EDGE_THREASHOLD 200
#define BORDER_CELL_RATIO 4
#define _USE_MATH_DEFINES
#define HOUGH_THETA CV_PI/180
#define HOUGH_RESOLUTION 1
#define HOUGH_THRESHOLD(count) (count * 1)
#define DRAWLINE_MULT 5
#define WHITE_BLACK_THRESH 127

#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <iostream>
#include <fstream>
#include <cstring>
#include <string>
#include <sstream>
#include <bitset>
#include <cmath>
#include <stdio.h>
#include <opencv2/opencv.hpp>
#include <opencv2/opencv.hpp>
#include <opencv2/features2d.hpp>
#include <opencv2/videoio.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/calib3d.hpp>
#include <opencv2/highgui.hpp>
#include <vector>
#include <iostream>
#include <iomanip>
#include <opencv2/features2d.hpp>
#include <cmath>

using namespace cv;
using namespace std;

const Vec3b color[8] = {
   Vec3b(0, 0, 0),       // black   - 000
   Vec3b(255, 255, 255), // white   - 001
   Vec3b(0, 0, 255),     // red     - 010
   Vec3b(0, 255, 0),     // green   - 011
   Vec3b(0, 255, 255),   // yellow  - 100
   Vec3b(255, 0, 0),     // blue    - 101   
   Vec3b(255, 0, 255),   // magenta - 110
   Vec3b(255, 255, 0)    // cyan    - 111
};
const enum {
   black = 0,
   white,
   red,
   green,
   yellow,
   blue,
   magenta,
   cyan
};

void showImg(const Mat& img, string name, int shrinkVal = 1) {
   namedWindow(name, WINDOW_NORMAL);
   imwrite(name, img);
   resizeWindow(name, Size(img.cols / shrinkVal, img.rows / shrinkVal));
   imshow(name, img);
   
}

void writeCell(Mat& db, const int cellN, const int cellIndex, const int val, const int offset = 0) {
   int cellWidth = (db.cols - (2 * offset)) / cellN;
   int r = ((cellIndex / cellN) * cellWidth) + offset;
   int c = ((cellIndex % cellN) * cellWidth) + offset;
   for (int row = 0; row < cellWidth; row++) {
      for (int col = 0; col < cellWidth; col++) {
         db.at<Vec3b>(r + row, c + col) = color[val];
      }
   }
}

Mat drawBorder(const Mat& input, vector<int> ratios, const int cellN) {
   const int borderWidth1 = input.cols / cellN / BORDER_CELL_RATIO; // border width for 1 ratio
   Mat output = input.clone();

   // draw all border
   int currentRatio = 0;
   int offsetFromBorder = 0;
   bool isWhite = true;
   while (currentRatio < ratios.size()) {
      for (int i = offsetFromBorder; i < (ratios[currentRatio] * borderWidth1) + offsetFromBorder; i++) {
         for (int j = offsetFromBorder; j < input.cols - offsetFromBorder; j++) {
            output.at<Vec3b>(j, i) = color[isWhite];
            output.at<Vec3b>(i, j) = color[isWhite];
            output.at<Vec3b>(j, input.cols - 1 - i) = color[isWhite];
            output.at<Vec3b>(input.cols - 1 - i, j) = color[isWhite];
         }
      }
      offsetFromBorder += (ratios[currentRatio] * borderWidth1); // set offset to point left at
      currentRatio++;
      isWhite = !isWhite;
   }

   // add cover top left corner with black and all others with white
   for (int i = 0; i < offsetFromBorder; i++) {
      for (int j = 0; j < offsetFromBorder; j++) {
         output.at<Vec3b>(i, j) = color[black];
         output.at<Vec3b>(output.cols - 1 - i, j) = color[white];
         output.at<Vec3b>(j, output.cols - 1 - i) = color[white];
         output.at<Vec3b>(output.cols - 1 - j, output.cols - 1 - i) = color[white];
      }
   }

   return output;
}

Mat makeDataBox(const char* data, const int dataArrSize, const int cellN, const int dbWidth, const int bitsPerCell, const vector<int> ratios) {
   const int dims[] = { dbWidth, dbWidth };
   const int cellWidth = dbWidth / cellN;
   Mat db(2, dims, CV_8UC3, Scalar::all(0));
   if (bitsPerCell > 3 || bitsPerCell < 1) {
      std::cout << "ERROR: can only do 1,2,3 bits per cell. Input: " << bitsPerCell << endl;
      return db;
   }

   db = drawBorder(db, ratios, cellN);
   int borderOffset = 0;
   int BorderBase1 = db.cols / cellN / BORDER_CELL_RATIO;
   for (int i : ratios) borderOffset += (i * BorderBase1);

   int val = 0;
   int bitIndex = 0;
   while (bitIndex < (dataArrSize * 8)) {
      if ((bitIndex) / bitsPerCell >= (cellN * cellN)) {
         //std::cout << "ERROR: to much data for this box" << endl;
         //std::cout << "ERROR: missed " << (dataArrSize * 8) - bitIndex << " bits or " << ((dataArrSize * 8) - bitIndex) / 8 << " bytes" << endl;
         break;
      }
      if (BIT_ISSET(data[bitIndex / 8], bitIndex % 8)) {
         //std::cout << "1";
         val += pow(2, bitIndex % bitsPerCell);


      }
      else cout << "0";
      if ((bitIndex + 1) % bitsPerCell == 0) {
         writeCell(db, cellN, (((bitIndex + 1) / bitsPerCell) - 1), val, borderOffset);
         val = 0;
      }
      bitIndex++;
   }
   if (val != 0) writeCell(db, cellN, (((bitIndex + 1) / bitsPerCell) - 1), val, borderOffset);
   return db;
}

string toAscii(string binaryValues) {
   string test = "";
   for (int i = 0; i < binaryValues.length(); i += 8) {
      string flipped = "";
      for (int j = 0; j < 8; j++) {
         flipped += binaryValues[i + 7 - j];
      }
      test += flipped;
   }
   stringstream sstream(test);
   string text;
   while (sstream.good()) {
      bitset<8> bits;
      sstream >> bits;
      char c = char(bits.to_ulong());
      text += c;

   }
   return text;
}

string findColorValue(Mat& patch) {
   int average[] = { 0, 0, 0 };
   int size = patch.rows * patch.cols;

   for (int r = 0; r < patch.rows; r++) {
      for (int c = 0; c < patch.cols; c++) {
         for (int a = 0; a < 3; a++) {
            average[a] += patch.at<Vec3b>(r, c)[a];
         }
      }
   }

   for (int j = 0; j < 3; j++) {
      average[j] = average[j] / size;
   }

   int closest = 255;
   int val;
   for (int i = 0; i < 8; i++) {
      int temp = 0;
      for (int h = 0; h < 3; h++) {
         temp += abs(color[i][h] - average[h]);
      }
      if (temp < closest) {
         closest = temp;
         val = i;
      }
   }
   string output = bitset<3>(val).to_string();
   string s = "";
   for (int i = 0; i < 3; i++) {
      s += output[2 - i];
   }
   return s;

}

void readDataBox(const Mat& db, const int bitsPerCell, const int resolution) {

   if (bitsPerCell > 3 || bitsPerCell < 1) {
      std::cout << "ERROR: can only do 1,2,3 bits per cell. Input: " << bitsPerCell << endl;
      return;
   }
   const int bitCount = bitsPerCell * resolution * resolution;
   int cellWidth = db.cols / resolution;
   int cellHeight = db.rows / resolution;
   string binaryString = "";
   int count = 0;
   char curLet = 0;
   for (int xCellPos = cellWidth / 2; xCellPos < db.cols; xCellPos += cellWidth) {
      for (int yCellPos = cellHeight / 2; yCellPos < db.rows; yCellPos += cellHeight) {
         int r = yCellPos - (cellHeight / 3);
         int c = xCellPos - (cellWidth / 3);
         int w = (cellWidth / 3) * 2;
         int h = (cellHeight / 3) * 2;

         Mat patch = db(Rect(r, c, w, h));
         string temp = findColorValue(patch);

         binaryString += temp;

      }
   }
   std::cout << "binary string output: " << binaryString << endl;
   string outputMessage = toAscii(binaryString);
   std::cout << "output: " << outputMessage << endl;
   ofstream message("OutputMessage.txt");
   message << outputMessage;
   message.close();

}

int getError100(const float a, const float b) {
   if (a - b == 0) return 0; // cant divide by 0, but 0 is perfect val
   return (abs(a - b) * 100) / a;
}

bool ratioMatch(vector<int> ratioFound, vector<int> ratioDB) {
   for (int i = 1; i < ratioDB.size() - 1; i++) {
      float avgBase = (ratioFound[6] + ratioFound[7]) / 2; // HARD CODED ()
      float val = ratioFound[i] / avgBase; // divide by the first number for ratio
      if (getError100((float)ratioDB[i], val) > BORDER_PERCENT_ERROR_THRESHHOLD) {
         return false;
      }
   }
   return true;
}

bool ratioMatchFlipped(vector<int> ratioFound, vector<int> ratioDB) {
   for (int i = 1; i < ratioDB.size() - 1; i++) {
      float avgBase = (ratioFound[2] + ratioFound[3]) / 2; // HARD CODED ()
      float val = ratioFound[i] / avgBase; // divide by the first number for ratio
      if (getError100((float)ratioDB[i], val) > BORDER_PERCENT_ERROR_THRESHHOLD) {
         return false;
      }
   }
   return true;
}

pair<Vec2f, Vec2f> findDataBoxWEdgeImageH(const Mat& input, vector<int> ratios) {
   vector<Point> outputLeft;
   vector<Point> outputRight;
   vector<int> currentPattern;
   vector<int> currentPositions;
   vector<int> ratiosFlipped;
   for (int i = ratios.size() - 1; i >= 0; i--)
      ratiosFlipped.push_back(ratios[i]);

   for (int r = 0; r < input.rows; r++) {
      int lastEdge = -1;
      for (int c = 0; c < input.cols; c++) {
         bool edge = input.at<Vec<uchar, 1>>(r, c)[0] > EDGE_THREASHOLD;
         if (edge) {
            currentPattern.push_back(c - lastEdge);
            currentPositions.push_back(c);
            if (currentPattern.size() > ratios.size()) {
               for (int i = 0; i < currentPattern.size() - 1; i++) {
                  currentPattern[i] = currentPattern[i + 1];
                  currentPositions[i] = currentPositions[i + 1];
               }
               currentPattern.pop_back();
               currentPositions.pop_back();
            }
            if (currentPattern.size() == ratios.size()) {
               if (ratioMatch(currentPattern, ratios)) {
                  outputLeft.push_back(Point(lastEdge + currentPattern[6] + currentPattern[7] - 2, r));
               }
               else if (ratioMatchFlipped(currentPattern, ratiosFlipped)) {
                  outputRight.push_back(Point(currentPositions[0] - currentPattern[2] - currentPattern[3] + 2, r));
               }
            }
            lastEdge = c;
         }
      }
      currentPattern.clear();
      currentPositions.clear();
   }

   // Inefficient, but make matricies to pass to hough transform API
   Mat outputRightImage(Size(input.cols, input.cols), CV_8UC1, Scalar(0));
   for (Point p : outputRight) outputRightImage.at<Vec<uchar, 1>>(p.y, p.x)[0] = 255;
   Mat outputLeftImage(Size(input.cols, input.cols), CV_8UC1, Scalar(0));
   for (Point p : outputLeft) outputLeftImage.at<Vec<uchar, 1>>(p.y, p.x)[0] = 255;

   //Mat slideDeckR = input.clone();
   //Mat slideDeckL = input.clone();
   //cvtColor(slideDeckR, slideDeckR, COLOR_GRAY2BGR);
   //GaussianBlur(slideDeckR, slideDeckR, Size(7, 7), 2, 2);
   //cvtColor(slideDeckL, slideDeckL, COLOR_GRAY2BGR);
   //GaussianBlur(slideDeckL, slideDeckL, Size(7, 7), 2, 2);
   //for (Point p : outputRight) circle(slideDeckR, p, 5, color[green], 3);
   //for (Point p : outputLeft) circle(slideDeckL, p, 5, color[green], 3);
   //showImg(slideDeckR, "slideDeckRH.jpg");
   //showImg(slideDeckL, "slideDeckLH.jpg");
   //waitKey(0);

   // top horizontal line
   vector<Vec2f> outputLeftLine;
   float thresholdL = HOUGH_THRESHOLD(outputLeft.size());
   while (outputLeftLine.size() == 0) {
      HoughLines(outputLeftImage, outputLeftLine, HOUGH_RESOLUTION, HOUGH_THETA, thresholdL);
      if (outputLeftLine.size() == 0) thresholdL -= HOUGH_THRESHOLD(outputLeft.size()) / 20;
      if (thresholdL <= 0) break;
   }

   // bottom horizontal line
   vector<Vec2f> outputRightLine;
   float thresholdR = HOUGH_THRESHOLD(outputRight.size());
   while (outputRightLine.size() == 0) {
      HoughLines(outputRightImage, outputRightLine, HOUGH_RESOLUTION, HOUGH_THETA, thresholdR);
      if (outputRightLine.size() == 0) thresholdR -= HOUGH_THRESHOLD(outputRight.size()) / 20;
      if (thresholdR <= 0) break;
   }


   Vec2f lineRight = { 0,0 };
   for (Vec2f v : outputRightLine) {
      double a = cos(v[1]), b = sin(v[1]);
      double x0 = a * v[0], y0 = b * v[0];
      lineRight[0] += x0;
      lineRight[1] += y0;
   }
   lineRight[0] /= outputRightLine.size();
   lineRight[1] /= outputRightLine.size();

   Vec2f lineLeft = { 0,0 };
   for (Vec2f v : outputLeftLine) {
      double a = cos(v[1]), b = sin(v[1]);
      double x0 = a * v[0], y0 = b * v[0];
      lineLeft[0] += x0;
      lineLeft[1] += y0;
   }
   lineLeft[0] /= outputLeftLine.size();
   lineLeft[1] /= outputLeftLine.size();

   pair<Vec2f, Vec2f> output(lineLeft, lineRight);
   return output;
}

pair<Vec2f, Vec2f> findDataBoxWEdgeImageV(const Mat& input, vector<int> ratios) {
   vector<Point> outputLeft;
   vector<Point> outputRight;
   vector<int> currentPattern;
   vector<int> currentPositions;
   vector<int> ratiosFlipped;
   for (int i = ratios.size() - 1; i >= 0; i--)
      ratiosFlipped.push_back(ratios[i]);

   for (int c = 0; c < input.cols; c++) {
      int lastEdge = -1;
      for (int r = 0; r < input.rows; r++) {
         bool edge = input.at<Vec<uchar, 1>>(r, c)[0] > EDGE_THREASHOLD;
         if (edge) {
            currentPattern.push_back(r - lastEdge);
            currentPositions.push_back(r);
            if (currentPattern.size() > ratios.size()) {
               for (int i = 0; i < currentPattern.size() - 1; i++) {
                  currentPattern[i] = currentPattern[i + 1];
                  currentPositions[i] = currentPositions[i + 1];
               }
               currentPattern.pop_back();
               currentPositions.pop_back();
            }
            if (currentPattern.size() == ratios.size()) {
               if (ratioMatch(currentPattern, ratios)) {
                  outputLeft.push_back(Point(c, lastEdge + currentPattern[6] + currentPattern[7] - 2));
               }
               else if (ratioMatchFlipped(currentPattern, ratiosFlipped)) {
                  outputRight.push_back(Point(c, currentPositions[0] - currentPattern[2] - currentPattern[3] + 2));
               }
            }
            lastEdge = r;
         }
      }
      currentPattern.clear();
      currentPositions.clear();
   }

   // Inefficient, but make matricies to pass to hough transform API
   Mat outputRightImage(Size(input.cols, input.cols), CV_8UC1, Scalar(0));
   for (Point p : outputRight) outputRightImage.at<Vec<uchar, 1>>(p.y, p.x)[0] = 255;
   Mat outputLeftImage(Size(input.cols, input.cols), CV_8UC1, Scalar(0));
   for (Point p : outputLeft) outputLeftImage.at<Vec<uchar, 1>>(p.y, p.x)[0] = 255;

   ////Mat slideDeckR(Size(input.cols, input.cols), CV_8UC3, Scalar(0));
   //Mat slideDeckR = input.clone();
   //Mat slideDeckL = input.clone();
   //cvtColor(slideDeckR, slideDeckR, COLOR_GRAY2BGR);
   //GaussianBlur(slideDeckR, slideDeckR, Size(7, 7), 2, 2);
   //cvtColor(slideDeckL, slideDeckL, COLOR_GRAY2BGR);
   //GaussianBlur(slideDeckL, slideDeckL, Size(7, 7), 2, 2);
   //for (Point p : outputRight) circle(slideDeckR, p, 5, color[green], 3);
   //for (Point p : outputLeft) circle(slideDeckL, p, 5, color[green], 3);
   //showImg(slideDeckR, "slideDeckRV.jpg");
   //showImg(slideDeckL, "slideDeckLV.jpg");
   //waitKey(0);

   vector<Vec2f> outputLeftLine;
   float thresholdL = HOUGH_THRESHOLD(outputLeft.size());
   while (outputLeftLine.size() == 0) {
      HoughLines(outputLeftImage, outputLeftLine, HOUGH_RESOLUTION, HOUGH_THETA, thresholdL);
      if (outputLeftLine.size() == 0) thresholdL -= HOUGH_THRESHOLD(outputLeft.size()) / 6;
      if (thresholdL <= 0) break;
   }

   // bottom horizontal line
   vector<Vec2f> outputRightLine;
   float thresholdR = HOUGH_THRESHOLD(outputRight.size());
   while (outputRightLine.size() == 0) {
      HoughLines(outputRightImage, outputRightLine, HOUGH_RESOLUTION, HOUGH_THETA, thresholdR);
      if (outputRightLine.size() == 0) thresholdR -= HOUGH_THRESHOLD(outputRight.size()) / 6;
      if (thresholdR <= 0) break;
   }

   Vec2f lineRight = { 0,0 };
   for (Vec2f v : outputRightLine) {
      double a = cos(v[1]), b = sin(v[1]);
      double x0 = a * v[0], y0 = b * v[0];
      lineRight[0] += x0;
      lineRight[1] += y0;
   }
   lineRight[0] /= outputRightLine.size();
   lineRight[1] /= outputRightLine.size();

   Vec2f lineLeft = { 0,0 };
   for (Vec2f v : outputLeftLine) {
      double a = cos(v[1]), b = sin(v[1]);
      double x0 = a * v[0], y0 = b * v[0];
      lineLeft[0] += x0;
      lineLeft[1] += y0;
   }
   lineLeft[0] /= outputLeftLine.size();
   lineLeft[1] /= outputLeftLine.size();

   pair<Vec2f, Vec2f> output(lineLeft, lineRight);
   return output;
}

void drawLineStandardXY(Mat& img, Vec2f v) {
   Point pt1(cvRound(v[0] + DRAWLINE_MULT * (-v[1])), cvRound(v[1] + DRAWLINE_MULT * (v[0])));
   Point pt2(cvRound(v[0] - DRAWLINE_MULT * (-v[1])), cvRound(v[1] - DRAWLINE_MULT * (v[0])));
   line(img, pt1, pt2, Scalar(0, 0, 255), 3, LINE_AA);
}

Point findWallIntersection(Vec2f v1, Vec2f v2) {
   Point l1s(v1[0] - v1[1], v1[0] + v1[1]);
   Point l1e(v1[0] + v1[1], -v1[0] + v1[1]);
   Point l2s(v2[0] - v2[1], v2[0] + v2[1]);
   Point l2e(v2[0] + v2[1], -v2[0] + v2[1]);

   double a1 = l1e.y - l1s.y;
   double b1 = l1s.x - l1e.x;
   double c1 = a1 * (l1s.x) + b1 * (l1s.y);

   // Line CD represented as a2x + b2y = c2
   double a2 = l2e.y - l2s.y;
   double b2 = l2s.x - l2e.x;
   double c2 = a2 * (l2s.x) + b2 * (l2s.y);

   double determinant = a1 * b2 - a2 * b1;

   if (determinant == 0)
   {
      // The lines are parallel. This is simplified
      // by returning a pair of FLT_MAX
      return Point(FLT_MAX, FLT_MAX);
   }
   else
   {
      double x = (b2 * c1 - b1 * c2) / determinant;
      double y = (a1 * c2 - a2 * c1) / determinant;
      return Point(x, y);
   }
}

int findRotation(const Mat& img, Point2f* srcPoints, Point2f* dstPointsForRotation) {
   Mat colorCheck;
   Mat Matrix = getPerspectiveTransform(srcPoints, dstPointsForRotation);
   warpPerspective(img, colorCheck, Matrix, Size(500, 500));
   if (colorCheck.at<Vec3b>(0, 0)[0] < WHITE_BLACK_THRESH && colorCheck.at<Vec3b>(0, 0)[1] < WHITE_BLACK_THRESH && colorCheck.at<Vec3b>(0, 0)[2] < WHITE_BLACK_THRESH)
      return -1;
   if (colorCheck.at<Vec3b>(0, colorCheck.cols - 1)[0] < WHITE_BLACK_THRESH && colorCheck.at<Vec3b>(0, colorCheck.cols - 1)[1] < WHITE_BLACK_THRESH && colorCheck.at<Vec3b>(0, colorCheck.cols - 1)[2] < WHITE_BLACK_THRESH)
      return ROTATE_90_COUNTERCLOCKWISE;
   if (colorCheck.at<Vec3b>(colorCheck.rows - 1, 0)[0] < WHITE_BLACK_THRESH && colorCheck.at<Vec3b>(colorCheck.rows - 1, 0)[1] < WHITE_BLACK_THRESH && colorCheck.at<Vec3b>(colorCheck.rows - 1, 0)[2] < WHITE_BLACK_THRESH)
      return ROTATE_90_CLOCKWISE;
   if (colorCheck.at<Vec3b>(colorCheck.rows - 1, colorCheck.cols - 1)[0] < WHITE_BLACK_THRESH && colorCheck.at<Vec3b>(colorCheck.rows - 1, colorCheck.cols - 1)[1] < WHITE_BLACK_THRESH && colorCheck.at<Vec3b>(colorCheck.rows - 1, colorCheck.cols - 1)[2] < WHITE_BLACK_THRESH)
      return ROTATE_180;
   return -1;
}

Mat findDataBox(const Mat& img, vector<int> ratios) {
   Mat edgeImage = img.clone();

   GaussianBlur(edgeImage, edgeImage, Size(7, 7), 2, 2);
   cvtColor(edgeImage, edgeImage, COLOR_BGR2GRAY);
   Canny(edgeImage, edgeImage, 20, 60);

   pair<Vec2f, Vec2f> pointsH = findDataBoxWEdgeImageH(edgeImage, ratios);
   pair<Vec2f, Vec2f> pointsV = findDataBoxWEdgeImageV(edgeImage, ratios);

   //Mat EdgeCopy = edgeImage.clone();
   //GaussianBlur(EdgeCopy, EdgeCopy, Size(5, 5), 2, 2);
   //showImg(EdgeCopy, "edgeImageBefore.jpg", 4);
   //waitKey(0);
   //cvtColor(EdgeCopy, EdgeCopy, COLOR_GRAY2BGR);
   //drawLineStandardXY(EdgeCopy, pointsH.first);
   //drawLineStandardXY(EdgeCopy, pointsH.second);
   //drawLineStandardXY(EdgeCopy, pointsV.first);
   //drawLineStandardXY(EdgeCopy, pointsV.second);
   //showImg(EdgeCopy, "edgeImageAfter.jpg", 4);
   //waitKey(0);

   Point p = findWallIntersection(pointsH.first, pointsV.first);
   Point2f c1 = findWallIntersection(pointsH.first, pointsV.first);
   Point2f c2 = findWallIntersection(pointsH.first, pointsV.second);
   Point2f c3 = findWallIntersection(pointsH.second, pointsV.first);
   Point2f c4 = findWallIntersection(pointsH.second, pointsV.second);

   // unskew the image
   Mat unskewed_image;
   Point2f srcPoints[] = { c1, c3, c2, c4 };
   Point2f dstPoints[] = { Point(0,0), Point(500, 0), Point(0, 500), Point(500, 500) };
   Point2f dstPointsForRotation[] = { Point(40,40), Point(460, 40), Point(40, 460), Point(460, 460) };
   Mat Matrix = getPerspectiveTransform(srcPoints, dstPoints);
   warpPerspective(img, unskewed_image, Matrix, Size(500, 500));

   int rotation = findRotation(img, srcPoints, dstPointsForRotation);
   if (rotation != -1) {
      rotate(unskewed_image, unskewed_image, rotation);
   }

   //showImg(unskewed_image, "unskew.jpg");
   waitKey(0);
   return unskewed_image;
}

int main(int argc, char* argv[])
{
   //string s = "da";
   //string s = "test data: our names are griffin, camas, and rahul. we are the coolest";
   //string s = "test data: our names are griffin, camas, and rahul. we are the coolest. we are in the css487 class with professor olsen. rahul's aaaaaaaa";
   string s = "Computer vision is the study of methods to extract content from digital images/video for applications such as recognizing people, navigating in an unfamiliar environment, image-based rendering, and retrieving images from a vast library. This class will examine all stages of computer vision from low-level to high-level. Low-level tasks include noise reduction and edge detection. In the middle, are estimating 3D properties of the scene, determining the camera motion from an image sequence, and segmentation of an image into coherent subsets. At the highest level, object ///recognition and scene interpretation are performed.";
   std::cout << "length = " << s.length() << endl;
   const char* sd = s.data();
   char* dataOut = (char*)malloc(sizeof(char) * (s.length() + 1));

   vector<int> borderRatios = { 2, 6, 2, 3, 2, 2, 1, 1, 3, 2 }; // ratio 1:6:2:3:2:2 total p = 16 = 4 cells (DO NOT CHANGE) RatioMatch function has HARD CODE

   Mat overlay = makeDataBox(sd, s.length(), 32, 1024, 3, borderRatios);
   //showImg(overlay, "overlay.jpg");
   //waitKey(0);
   Mat real = imread("testReal14.jpg");

   Mat result = findDataBox(real, borderRatios);
   showImg(result, "result.jpg");
   waitKey(0);

   return 0;
}
